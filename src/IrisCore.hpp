/**
 * @file IrisCore.hpp
 * @author Ryan Landvater
 * @brief  Iris Core API Documentation.
 * @version 2024.0.3
 * @date 2024-08-26
 *
 * @copyright Copyright (c) 2023-24
 * Created by Ryan Landvater on 8/26/23.
 *
 */

#include <stdint.h>
#include <vector>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <thread>
#include <shared_mutex>
#include <functional>
#include "IrisTypes.hpp"


#ifndef IrisCore_h
#define IrisCore_h

namespace Iris {
/**
 * @brief Get the major version of Iris within the binaries.
 * 
 * @return int major version
 */
int get_major_version ();
/**
 * @brief Get the minor version of Iris within the binaries.
 * 
 * @return int minor version
 */
int get_minor_version ();
/**
 * @brief Get the build number of these binaries.
 * 
 * @return int build number.
 */
int get_build_number  ();

/**
 * @brief The viewer the the primary control class that interfaces between external
 * applications and their views, and the iris rendering system. It contains interface
 * capabilities between external controllers, coordinates display presentations between
 * external surfaces, and creates any user interface functionalities defined in user
 * interface markup strctures.
 * @ref __INTERNAL__Viewer is internally defined and not externally exposed.
 */
using Viewer = std::shared_ptr <class __INTERNAL__Viewer>;

/**
 * @brief Create an Iris viewer instance.
 * 
 * The viewer is the primary interface between the whole slide rendering 
 * system and the calling application that is using Iris to draw slide views. 
 * Use the below @ref viewer_bind_external_surface to bind and initialize the system.
 * 
 * \note This function **only creates / initializes** the viewer.
 * **It does not initialize it.** The viewer must be bound to a application
 *  surface generated by the operating system before it can be used.
 *
 * @return Valid Viewer handle on success
 * @return Nullptr on failure
 */
Viewer create_viewer                (const ViewerCreateInfo&);

/**
 * @brief Bind a viewer to an external surface controlled by the calling application.
 * 
 * Unbind the viewer before destroying the view or allow the viewer to exit scope
 * and it will automatically unbind the surface.
 * \note The provided surface outlive the viewer once bound. Alternatively, the
 * viewer can be unbound via viewer_unbind_surface(const Viewer&);
 *
 * @return true when the system has sucessfully configured
 * @return false when the system failed to effectively configure.
 */
bool viewer_bind_external_surface   (const ViewerBindExternalSurfaceInfo&);


/**
 * @brief Unbind the external drawing surface controlled by the calling application.
 * 
 * \note For objective-C implementations, this will break the ARC loop and allow the
 * proper program breakdown
 * 
 * @param viewer Iris::Viewer handle
 */
void viewer_unbind_surface          (const Viewer& viewer);

/**
 * @brief Inform a viewer that the attached window was resized. 
 * 
 * This will force a reconstruction of the viewer rendering engine's 
 * swapchain to accomodate the new window size. It will also resize
 * any optional UI scene object locations / R-tree orderings.
 * 
 * @param viewer Iris::Viewer handle
 */
void viewer_window_resized          (const Viewer& viewer);

/**
 * @brief Create and open a slide for viewing. 
 * 
 * This will close any currently opened slide within the viewer and 
 * attempt to open a new slide using the file information defined 
 * within Iris::SlideOpenInfo structure.
 * Use the Iris::viewer_open_slide(const Iris::Viewer&, const Iris::Slide&)
 * function if there is already an active Iris::Slide object opened via
 * Iris::create_slide(const Iris::SlideOpenInfo&) call with valid info;
 * 
 * @param viewer Iris::Viewer handle
 * @param info slide file information
 */
void viewer_open_slide              (const Viewer& viewer, const SlideOpenInfo& info);

/**
 * @brief Load and begin rendering the supplied active Iris Slide. 
 * 
 * This will close any currently opened slide and attempt to render 
 * the provided Iris::Slide object, if it is a valid slide handle.
 * 
 * @param viewer Iris::Viewer handle
 */
void viewer_open_slide              (const Viewer& viewer, const Slide&);

/**
 * @brief Close the current slide being viewed by the viewer.
 * 
 * @param viewer Iris::Viewer handle
 */
void viewer_close_slide             (const Viewer& viewer);

/**
 * @brief Get the current slide being viewed by the viewer. Returns a Slide nullptr on failure
 * 
 * @param viewer Iris::Viewer handle
 * @return Valid Slide handle on success
 * @return Nullptr on failure.
 */
Slide viewer_get_active_slide       (const Viewer& viewer);

/**
 * @brief Translate the scope view when rendering a whole slide image.
 * 
 * @param viewer Iris::Viewer handle
 */
void viewer_engine_translate        (const Viewer& viewer, const ViewerTranslateScope&) noexcept;

/**
 * @brief Change the scope view amound when rending a whole slide image.
 * 
 * @param viewer Iris::Viewer handle
 */
void viewer_engine_zoom             (const Viewer& viewer, const ViewerZoomScope&) noexcept;

/**
 * @brief Insert an image slide annotation into the current active slide at the location within the screen.
 * 
 * @param viewer Iris::Viewer handle
 */
void viewer_annotate_slide          (const Viewer& viewer, const SlideAnnotation&) noexcept;

//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
//     Iris Slide Image Handler                                             //
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

/**
 * @brief Create an Iris::Slide object encapsulating access to a whole
 * slide image object.
 * 
 * The Slide object has a variety of interal functionalities in addition to
 * mapping the WSI file. This includes asynchronous non-blocking read threads
 * that load the slide tile image data. 
 * 
 * \note Iris::iewer_open_slide(const Viewer& viewer, const Slide&) is the 
 * preferred method as it allows the Iris Render Engine to configure optional
 * performance parameters.
 * 
 * @param info Iris::SlideOpenInfo structure
 * 
 * @return Valid Iris::Slide handle on success
 * @return Nullptr on failure
 */
Slide create_slide                  (const SlideOpenInfo& info);

//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
//      Data Buffer Wrapper                                                 //
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

/**
 * @brief Create a **strong** buffer but without memory backing. 
 * 
 * This is copy constructable and will maintain the life of the underlying
 * data (once allocated) as long as one copy persists.
 * Configure the memory backing afterwards by expanding the data block.  
 * This function will construct a strong buffer object with 'capacity' and 'size' of 0-bytes,
 * 
 * \note Despite being a strong buffer, there is no owned data block yet. It must be initialized first.
 * 
 * @return Valid Iris::Buffer handle on success but without data block backing.
 * @return Nullptr on failure
 */
Buffer  Create_strong_buffer        ();

/**
 * @brief Create a **strong** blank buffer with an initial capacity of @ref "buffer_size_in_bytes" bytes long.
 * 
 * This is copy constructable and will maintain the life of the underlying
 * data (once allocated) as long as one copy persists. The size will be 0, despite 
 * the capacity being defined.
 * 
 * @param buffer_size_in_bytes the initial **capacity** (in bytes). The internal 'size' is '0' bytes
 * @return Valid Iris::Buffer handle with size 0 bytes on success
 * @return Nullptr on failure
 */
Buffer  Create_strong_buffer        (size_t buffer_size_in_bytes);

/**
 * @brief Create a **strong** buffer and copy the data pointed to by @ref dataptr and @ref bytes in length (in bytes).
 * 
 * This is copy constructable and will maintain the life of the underlying
 * data (once allocated) as long as one copy persists. The data pointed to by dataptr
 * will be copied into the returned buffer and **the data source can be safely freed at any time.**
 * 
 * @param data_ptr pointer to raw bytes to be copied into the new buffer
 * @param bytes number of bytes to copy into the buffer. This will be resulting buffer size.
 * @return Valid Iris::Buffer handle on success
 * @return Nullptr on failure
 * 
 */
Buffer Copy_strong_buffer_from_data (const void* data_ptr, size_t bytes);

/**
 * @brief Wrap a **weak buffer** around foreign data. This wrapper is used for implementing Iris Codec functions on
 * foreign data blocks without having to copy the data. 
 * 
 * This is  a convenience function for such tasks as decoding network derived large buffers sequences to reduce data 
 * copy and redundancy. Weak buffers can become strong should it be required. Doing so will force the buffer to adopt
 * responsibility for freeing the underlying data ** and may change or invalidate the pointer** 
 * to the underlying data should it need to expand the block.
 * 
 * \note This buffer has no ownership over the underlying data and **the underlying data must persist**
 * while the buffer is used.
 * \note The buffer can switch ownership to **strong** but doing so may invalidate the origianl @ref data_ref. 
 * 
 * @param data_ref 
 * @param bytes 
 * @return Valid Iris::Buffer (**weak ownership**) handle on success
 * @return Nullptr on failure
 * 
 */
Buffer  Wrap_weak_buffer_fom_data   (const void* const data_ref, size_t bytes);

/**
 * @brief Write data into a buffer in a safe manner. 
 * 
 * This is useful if you don't want to include the IrisCodec_buffer.h header and expose yourself
 * to accidentally using it wrong and corrupting your data. This function works like a c-style 
 * array exposed to a method for writing. Provide the buffer and size. This method functions 
 * differently based upon the strength of the reference (see discussion below)
 * 
 * If the reference is **STRONG**, this method will expose the begining of the next writable segment and will
 * expand the buffer if there is insufficient space. The buffer's internal size metric will reflect the new data.
 * 
 * \note If the reference is **weak**, this method will expose the begining of the buffer sequence 
 * **this will throw an exception** if there is insufficient space within the buffer (as weak buffers 
 * are not permitted to expand a buffer).
 * **If you are worried about a buffer overflow, you may consider strengthening the buffer reference 
 * to allow for expansion.**
 * 
 * @param buffer Iris::Buffer handle
 * @param bytes number of bytes to prepare for writing; size of the buffer will be expanded by this number of bytes
 * @return void* c-style data pointer to start writable memory (to populate with memcopy for example)
 * @return NULL-pointer in the event of failure.
 */
void*   Buffer_write_into_buffer    (const Buffer& byffer, size_t bytes);

/**
 * @brief Copy-extract the data from the underlying buffer structure. 
 * 
 * This is useful if you don't want to include the IrisCodecBuffer.h header and 
 * expose yourself to accidentally using it incorrectly and corrupting your memory.
 * 
 * @param buffer Iris::Buffer handle
 * @param data data pointer to copy the data into. If a null-ptr, only the @ref size will be returned.
 * @param bytes number of bytes copied out of the buffer handle
 */
void    Buffer_get_data             (const Buffer& buffer, void*& data, size_t& bytes);
}

#endif /* IrisCore_h */
