<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Iris Whole Slide Imaging: Iris::__INTERNAL__Buffer Class Reference</title>
<link rel="icon" href="Iris_logo.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Iris Whole Slide Imaging
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Iris</b></li><li class="navelem"><a class="el" href="class_iris_1_1_____i_n_t_e_r_n_a_l_____buffer.html">__INTERNAL__Buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_iris_1_1_____i_n_t_e_r_n_a_l_____buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Iris::__INTERNAL__Buffer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Private implementation of the reference counted data object used to wrap datablocks.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iris_buffer_8hpp_source.html">IrisBuffer.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a80a2c12ee0e45da5ebf22225088ea5" id="r_a3a80a2c12ee0e45da5ebf22225088ea5"><td class="memItemLeft" align="right" valign="top"><a id="a3a80a2c12ee0e45da5ebf22225088ea5" name="a3a80a2c12ee0e45da5ebf22225088ea5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__INTERNAL__Buffer</b> (<a class="el" href="iris_types_8hpp.html#aab7511ac29e04c5795cfc28bffb559af">BufferReferenceStrength</a>) noexcept</td></tr>
<tr class="separator:a3a80a2c12ee0e45da5ebf22225088ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4026fa35afa97dd2cd5079983d1d2b53" id="r_a4026fa35afa97dd2cd5079983d1d2b53"><td class="memItemLeft" align="right" valign="top"><a id="a4026fa35afa97dd2cd5079983d1d2b53" name="a4026fa35afa97dd2cd5079983d1d2b53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__INTERNAL__Buffer</b> (<a class="el" href="iris_types_8hpp.html#aab7511ac29e04c5795cfc28bffb559af">BufferReferenceStrength</a>, size_t <a class="el" href="#aef25184250bc213948be4fe83fb25cda">capacity</a>) noexcept</td></tr>
<tr class="separator:a4026fa35afa97dd2cd5079983d1d2b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b526678aa4fd666b49ee52a658413c" id="r_af3b526678aa4fd666b49ee52a658413c"><td class="memItemLeft" align="right" valign="top"><a id="af3b526678aa4fd666b49ee52a658413c" name="af3b526678aa4fd666b49ee52a658413c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__INTERNAL__Buffer</b> (<a class="el" href="iris_types_8hpp.html#aab7511ac29e04c5795cfc28bffb559af">BufferReferenceStrength</a>, const void *const <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60">data</a>, size_t bytes) noexcept</td></tr>
<tr class="separator:af3b526678aa4fd666b49ee52a658413c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41463a473bceb0038a4b9892b3c490f5" id="r_a41463a473bceb0038a4b9892b3c490f5"><td class="memItemLeft" align="right" valign="top"><a id="a41463a473bceb0038a4b9892b3c490f5" name="a41463a473bceb0038a4b9892b3c490f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__INTERNAL__Buffer</b> (const <a class="el" href="class_iris_1_1_____i_n_t_e_r_n_a_l_____buffer.html">__INTERNAL__Buffer</a> &amp;)=delete</td></tr>
<tr class="separator:a41463a473bceb0038a4b9892b3c490f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca24cddeb565df7e8a63647568b6714" id="r_acca24cddeb565df7e8a63647568b6714"><td class="memItemLeft" align="right" valign="top"><a id="acca24cddeb565df7e8a63647568b6714" name="acca24cddeb565df7e8a63647568b6714"></a>
<a class="el" href="class_iris_1_1_____i_n_t_e_r_n_a_l_____buffer.html">__INTERNAL__Buffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_iris_1_1_____i_n_t_e_r_n_a_l_____buffer.html">__INTERNAL__Buffer</a> &amp;)=delete</td></tr>
<tr class="separator:acca24cddeb565df7e8a63647568b6714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb39732e46e90d1634bc4db7b6937ee" id="r_acdb39732e46e90d1634bc4db7b6937ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdb39732e46e90d1634bc4db7b6937ee">operator void *const</a> () const</td></tr>
<tr class="memdesc:acdb39732e46e90d1634bc4db7b6937ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the beginning of the underlying data block.  <br /></td></tr>
<tr class="separator:acdb39732e46e90d1634bc4db7b6937ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac0ae896096a03e93511f7444d75a98" id="r_acac0ae896096a03e93511f7444d75a98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acac0ae896096a03e93511f7444d75a98">operator bool</a> () const</td></tr>
<tr class="memdesc:acac0ae896096a03e93511f7444d75a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator to see if the buffer reference is valid.  <br /></td></tr>
<tr class="separator:acac0ae896096a03e93511f7444d75a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4761191d45565721b2afb763496724" id="r_ade4761191d45565721b2afb763496724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iris_types_8hpp.html#aab7511ac29e04c5795cfc28bffb559af">BufferReferenceStrength</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade4761191d45565721b2afb763496724">get_strength</a> () const</td></tr>
<tr class="memdesc:ade4761191d45565721b2afb763496724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference strength to the underlying data wrapped by the buffer.  <br /></td></tr>
<tr class="separator:ade4761191d45565721b2afb763496724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44475f244c35efafebb96925fa76f74" id="r_ad44475f244c35efafebb96925fa76f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad44475f244c35efafebb96925fa76f74">change_strength</a> (<a class="el" href="iris_types_8hpp.html#aab7511ac29e04c5795cfc28bffb559af">BufferReferenceStrength</a> strength_to_assign)</td></tr>
<tr class="memdesc:ad44475f244c35efafebb96925fa76f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the strength of the underlying reference.  <br /></td></tr>
<tr class="separator:ad44475f244c35efafebb96925fa76f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7de65fe860a8fbb4ea2dd6df0dde60" id="r_a0b7de65fe860a8fbb4ea2dd6df0dde60"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60">data</a> () const</td></tr>
<tr class="memdesc:a0b7de65fe860a8fbb4ea2dd6df0dde60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to the <b>beginning</b> of the underlying data block.  <br /></td></tr>
<tr class="separator:a0b7de65fe860a8fbb4ea2dd6df0dde60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6206feb3f74a54b0492fd0c4643701" id="r_a0b6206feb3f74a54b0492fd0c4643701"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b6206feb3f74a54b0492fd0c4643701">end</a> () const</td></tr>
<tr class="memdesc:a0b6206feb3f74a54b0492fd0c4643701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the next unwritten location in the buffer.  <br /></td></tr>
<tr class="separator:a0b6206feb3f74a54b0492fd0c4643701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a90532206408c40b375e4c8afcbdde6" id="r_a6a90532206408c40b375e4c8afcbdde6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a90532206408c40b375e4c8afcbdde6">prepare</a> (size_t amount_of_bytes_to_prepare)</td></tr>
<tr class="memdesc:a6a90532206408c40b375e4c8afcbdde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the <b>capacity</b> of the buffer without affecting the size.  <br /></td></tr>
<tr class="separator:a6a90532206408c40b375e4c8afcbdde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eabe4c9fe5f8dff20231f1c8aee9f00" id="r_a0eabe4c9fe5f8dff20231f1c8aee9f00"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0eabe4c9fe5f8dff20231f1c8aee9f00">append</a> (size_t append_by_bytes)</td></tr>
<tr class="memdesc:a0eabe4c9fe5f8dff20231f1c8aee9f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the <b>size</b> of the buffer without writing data into the expanded space.  <br /></td></tr>
<tr class="separator:a0eabe4c9fe5f8dff20231f1c8aee9f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a883576e939f24c2ade0446c7ff7b79" id="r_a7a883576e939f24c2ade0446c7ff7b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a883576e939f24c2ade0446c7ff7b79">append</a> (void *<a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60">data</a>, size_t <a class="el" href="#afaedad0adf27cf64d597f24ceacc9fc9">size</a>)</td></tr>
<tr class="memdesc:a7a883576e939f24c2ade0446c7ff7b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the end of the buffer by copying data into the buffer.  <br /></td></tr>
<tr class="separator:a7a883576e939f24c2ade0446c7ff7b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaedad0adf27cf64d597f24ceacc9fc9" id="r_afaedad0adf27cf64d597f24ceacc9fc9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaedad0adf27cf64d597f24ceacc9fc9">size</a> () const</td></tr>
<tr class="memdesc:afaedad0adf27cf64d597f24ceacc9fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size of the buffer.  <br /></td></tr>
<tr class="separator:afaedad0adf27cf64d597f24ceacc9fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a3f0668dd8e516f2ea276c5edca6bb" id="r_a59a3f0668dd8e516f2ea276c5edca6bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59a3f0668dd8e516f2ea276c5edca6bb">set_size</a> (size_t buffer_valid_size_bytes)</td></tr>
<tr class="memdesc:a59a3f0668dd8e516f2ea276c5edca6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size object.  <br /></td></tr>
<tr class="separator:a59a3f0668dd8e516f2ea276c5edca6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef25184250bc213948be4fe83fb25cda" id="r_aef25184250bc213948be4fe83fb25cda"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef25184250bc213948be4fe83fb25cda">capacity</a> () const</td></tr>
<tr class="memdesc:aef25184250bc213948be4fe83fb25cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total capacity of the buffer (used and unused)  <br /></td></tr>
<tr class="separator:aef25184250bc213948be4fe83fb25cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca9918fef4b1aae964c3f733ef7fe66" id="r_a9ca9918fef4b1aae964c3f733ef7fe66"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ca9918fef4b1aae964c3f733ef7fe66">available_bytes</a> () const</td></tr>
<tr class="memdesc:a9ca9918fef4b1aae964c3f733ef7fe66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the remaining bytes within the buffer that are unused.  <br /></td></tr>
<tr class="separator:a9ca9918fef4b1aae964c3f733ef7fe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8570510a82f62e54f208dafb1a7c785" id="r_ab8570510a82f62e54f208dafb1a7c785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8570510a82f62e54f208dafb1a7c785">resize</a> (size_t expected_size_bytes)</td></tr>
<tr class="memdesc:ab8570510a82f62e54f208dafb1a7c785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the underlying datablock.  <br /></td></tr>
<tr class="separator:ab8570510a82f62e54f208dafb1a7c785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca6a558e1ea9ea6bc1fb7ef394591bf" id="r_a1ca6a558e1ea9ea6bc1fb7ef394591bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ca6a558e1ea9ea6bc1fb7ef394591bf">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:a1ca6a558e1ea9ea6bc1fb7ef394591bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the underlying data block to fit the used space.  <br /></td></tr>
<tr class="separator:a1ca6a558e1ea9ea6bc1fb7ef394591bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Private implementation of the reference counted data object used to wrap datablocks. </p>
<p>It can either strong reference or weak reference the underlying data. The buffer can also shift between weak and strong referrences if chosen; however, this is very dangerous obviously and you need to ensure you are tracking if you have switched from weak to strong or vice versa.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use of the <a class="el" href="class_iris_1_1_____i_n_t_e_r_n_a_l_____buffer.html" title="Private implementation of the reference counted data object used to wrap datablocks.">__INTERNAL__Buffer</a> is given as a courtesy for developers who want greater efficiency and control over datablocks. These methods were created for the internal use by Iris Developers and come with some inherant risk.</dd>
<dd>
<a class="el" href="class_iris_1_1_____i_n_t_e_r_n_a_l_____buffer.html" title="Private implementation of the reference counted data object used to wrap datablocks.">__INTERNAL__Buffer</a> is currently NOT thread safe. This will be fixed in future updates. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0eabe4c9fe5f8dff20231f1c8aee9f00" name="a0eabe4c9fe5f8dff20231f1c8aee9f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eabe4c9fe5f8dff20231f1c8aee9f00">&#9670;&#160;</a></span>append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Iris::__INTERNAL__Buffer::append </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>append_by_bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expands the <b>size</b> of the buffer without writing data into the expanded space. </p>
<p>This expands the buffer size without actually writing any data into the new buffer space. This is useful for streaming data where you may be aware of the size of incoming data but need a space for that data (off the network card) to be copied. If this expansion goes beyond <a class="el" href="#a9ca9918fef4b1aae964c3f733ef7fe66" title="Returns the remaining bytes within the buffer that are unused.">available_bytes()</a>, the data-block will be expanded similarly to <a class="el" href="#a6a90532206408c40b375e4c8afcbdde6" title="Extends the capacity of the buffer without affecting the size.">prepare(size_t)</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6a90532206408c40b375e4c8afcbdde6" title="Extends the capacity of the buffer without affecting the size.">prepare(size_t)</a>, <a class="el" href="#a9ca9918fef4b1aae964c3f733ef7fe66" title="Returns the remaining bytes within the buffer that are unused.">available_bytes()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this may invalidate any prior reference to the <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> pointer. Any local variables that reference the data within this buffer may become immediately invalid. You may check if resize changed the buffer by evaluating a comparison between <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> before calling and <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> after calling.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">append_by_bytes</td><td>the number of bytes by which to expand the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void* to the beginning of <b>writable space</b> where new data should be added. </dd></dl>

</div>
</div>
<a id="a7a883576e939f24c2ade0446c7ff7b79" name="a7a883576e939f24c2ade0446c7ff7b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a883576e939f24c2ade0446c7ff7b79">&#9670;&#160;</a></span>append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a> Iris::__INTERNAL__Buffer::append </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the end of the buffer by copying data into the buffer. </p>
<p>This works similarly to <a class="el" href="#a0eabe4c9fe5f8dff20231f1c8aee9f00" title="Expands the size of the buffer without writing data into the expanded space.">append(size_t)</a> but performs a copy transaction, copying the C-style array into the end of the current block.</p>
<dl class="section warning"><dt>Warning</dt><dd>this may invalidate any prior reference to the <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> pointer. Any local variables that reference the data within this buffer may become immediately invalid. You may check if resize changed the buffer by evaluating a comparison between <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> before calling and <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> after calling.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>C-style pointer to data array </td></tr>
    <tr><td class="paramname">size</td><td>Size of data in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IRIS_SUCCESS on successful appending of data to end of buffer </dd></dl>

</div>
</div>
<a id="a9ca9918fef4b1aae964c3f733ef7fe66" name="a9ca9918fef4b1aae964c3f733ef7fe66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca9918fef4b1aae964c3f733ef7fe66">&#9670;&#160;</a></span>available_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Iris::__INTERNAL__Buffer::available_bytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the remaining bytes within the buffer that are unused. </p>
<p>This value is equivalent to <a class="el" href="#aef25184250bc213948be4fe83fb25cda" title="Returns the total capacity of the buffer (used and unused)">capacity()</a> - <a class="el" href="#afaedad0adf27cf64d597f24ceacc9fc9" title="Returns the current size of the buffer.">size()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t unused bytes in the current data block </dd></dl>

</div>
</div>
<a id="aef25184250bc213948be4fe83fb25cda" name="aef25184250bc213948be4fe83fb25cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef25184250bc213948be4fe83fb25cda">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Iris::__INTERNAL__Buffer::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total capacity of the buffer (used and unused) </p>
<dl class="section return"><dt>Returns</dt><dd>size_t capacity in bytes </dd>
<dd>
IRIS_SUCCESS on successfully changing the internal size tracker </dd>
<dd>
IRIS_FAILURE type on failure to change the tracker </dd></dl>

</div>
</div>
<a id="ad44475f244c35efafebb96925fa76f74" name="ad44475f244c35efafebb96925fa76f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44475f244c35efafebb96925fa76f74">&#9670;&#160;</a></span>change_strength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a> Iris::__INTERNAL__Buffer::change_strength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="iris_types_8hpp.html#aab7511ac29e04c5795cfc28bffb559af">BufferReferenceStrength</a></td>          <td class="paramname"><span class="paramname"><em>strength_to_assign</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the strength of the underlying reference. </p>
<p>If switching to STRONG reference, this buffer will become responsible for the freeing of the underlying data. Whatever mallocated the data is NO LONGER RESPONSIBLE for FREEING the underlying data. If switched to WEAK reference, the buffer will give up the responsibility to free the data and it now becomes the <b>responsibility of the program to avoid a memory leak</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strength_to_assign</td><td>REFERENCE_WEAK or REFERENCE_STRONG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b7de65fe860a8fbb4ea2dd6df0dde60" name="a0b7de65fe860a8fbb4ea2dd6df0dde60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7de65fe860a8fbb4ea2dd6df0dde60">&#9670;&#160;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Iris::__INTERNAL__Buffer::data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to the <b>beginning</b> of the underlying data block. </p>
<p>This returns a pointer to the start of the datablock, not the start of unwritten data. If you wish to write into the buffer, use <a class="el" href="#a6a90532206408c40b375e4c8afcbdde6" title="Extends the capacity of the buffer without affecting the size.">prepare()</a> or <a class="el" href="#a0eabe4c9fe5f8dff20231f1c8aee9f00" title="Expands the size of the buffer without writing data into the expanded space.">append()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0b6206feb3f74a54b0492fd0c4643701" title="Returns a pointer to the next unwritten location in the buffer.">end()</a>, <a class="el" href="#a6a90532206408c40b375e4c8afcbdde6" title="Extends the capacity of the buffer without affecting the size.">prepare()</a>, and <a class="el" href="#a0eabe4c9fe5f8dff20231f1c8aee9f00" title="Expands the size of the buffer without writing data into the expanded space.">append()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void* a pointer to the start of the internal data wrapped by the buffer. </dd></dl>

</div>
</div>
<a id="a0b6206feb3f74a54b0492fd0c4643701" name="a0b6206feb3f74a54b0492fd0c4643701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6206feb3f74a54b0492fd0c4643701">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Iris::__INTERNAL__Buffer::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the next unwritten location in the buffer. </p>
<p>This has no effect on the size of the buffer. If the buffer needs to be resized use the <a class="el" href="#a0eabe4c9fe5f8dff20231f1c8aee9f00" title="Expands the size of the buffer without writing data into the expanded space.">append(size_t)</a> method to expand the buffer. </p><dl class="section see"><dt>See also</dt><dd>append_(size_t) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If this extends beyond the capacity, a nullptr is returned.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void* that points to the next unwritten byte in the buffer. </dd></dl>

</div>
</div>
<a id="ade4761191d45565721b2afb763496724" name="ade4761191d45565721b2afb763496724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4761191d45565721b2afb763496724">&#9670;&#160;</a></span>get_strength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iris_types_8hpp.html#aab7511ac29e04c5795cfc28bffb559af">BufferReferenceStrength</a> Iris::__INTERNAL__Buffer::get_strength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the reference strength to the underlying data wrapped by the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>REFERENCE_WEAK if the buffer only references the data and does not own it </dd>
<dd>
REFERENCE_STRONG if the buffer owns the data and controls the data lifetime </dd></dl>

</div>
</div>
<a id="acac0ae896096a03e93511f7444d75a98" name="acac0ae896096a03e93511f7444d75a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac0ae896096a03e93511f7444d75a98">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iris::__INTERNAL__Buffer::operator bool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator to see if the buffer reference is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a valid data block backs this buffer </dd>
<dd>
false if there is no valid data block backing this buffer </dd></dl>

</div>
</div>
<a id="acdb39732e46e90d1634bc4db7b6937ee" name="acdb39732e46e90d1634bc4db7b6937ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb39732e46e90d1634bc4db7b6937ee">&#9670;&#160;</a></span>operator void *const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iris::__INTERNAL__Buffer::operator void *const </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer to the beginning of the underlying data block. </p>
<dl class="section return"><dt>Returns</dt><dd>void* const </dd></dl>

</div>
</div>
<a id="a6a90532206408c40b375e4c8afcbdde6" name="a6a90532206408c40b375e4c8afcbdde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a90532206408c40b375e4c8afcbdde6">&#9670;&#160;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a> Iris::__INTERNAL__Buffer::prepare </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>amount_of_bytes_to_prepare</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends the <b>capacity</b> of the buffer without affecting the size. </p>
<p>This extends the amount of data that the buffer can hold and may lead to a resizing of the data block backing the buffer but without actually expanding the size of the committed data. This is useful if you know how much data to expect but do not have that data yet. If you wish to expand the size as well, see <a class="el" href="#a0eabe4c9fe5f8dff20231f1c8aee9f00" title="Expands the size of the buffer without writing data into the expanded space.">append()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0eabe4c9fe5f8dff20231f1c8aee9f00" title="Expands the size of the buffer without writing data into the expanded space.">append()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this may invalidate any prior reference to the <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> pointer. Any local variables that reference the data within this buffer may become immediately invalid. You may check if resize changed the buffer by evaluating a comparison between <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> before calling and <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> after calling.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount_of_bytes_to_prepare</td><td>the number of bytes by which to expand the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IRIS_SUCCESS on successful extension of buffer capacity </dd></dl>

</div>
</div>
<a id="ab8570510a82f62e54f208dafb1a7c785" name="ab8570510a82f62e54f208dafb1a7c785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8570510a82f62e54f208dafb1a7c785">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a> Iris::__INTERNAL__Buffer::resize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>expected_size_bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the underlying datablock. </p>
<p>This is fundamentally different from calling <a class="el" href="#a59a3f0668dd8e516f2ea276c5edca6bb" title="Set the size object.">set_size(size_t)</a> as it actually changes the size of the backing data block by the kernel. Calling this method can invalidate the underlying data pointer. </p><dl class="section note"><dt>Note</dt><dd>You should use <a class="el" href="#a6a90532206408c40b375e4c8afcbdde6" title="Extends the capacity of the buffer without affecting the size.">prepare()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this may invalidate any prior reference to the <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> pointer. Any local variables that reference the data within this buffer may become immediately invalid. You may check if resize changed the buffer by evaluating a comparison between <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> before calling and <a class="el" href="#a0b7de65fe860a8fbb4ea2dd6df0dde60" title="Returns pointer to the beginning of the underlying data block.">data()</a> after calling.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expected_size_bytes</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IRIS_SUCCESS on successfully resizing the buffer object </dd></dl>

</div>
</div>
<a id="a59a3f0668dd8e516f2ea276c5edca6bb" name="a59a3f0668dd8e516f2ea276c5edca6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a3f0668dd8e516f2ea276c5edca6bb">&#9670;&#160;</a></span>set_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a> Iris::__INTERNAL__Buffer::set_size </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>buffer_valid_size_bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the size object. </p>
<p>Assign the internal size of the complete buffer to the given size in bytes. If you are simply adding some number of bytes to the buffer, use append(size) instead.</p>
<dl class="section note"><dt>Note</dt><dd>This is an unsafe method and generally should not be used without a really good reason.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the argument is less than the current buffer size, this will cut that data to the given size. Unlike resize, the data will still persist but will be overwritten with the next call of append.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_valid_size_bytes</td><td>size in bytes to set the buffer's internal tracker </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result </dd></dl>

</div>
</div>
<a id="a1ca6a558e1ea9ea6bc1fb7ef394591bf" name="a1ca6a558e1ea9ea6bc1fb7ef394591bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca6a558e1ea9ea6bc1fb7ef394591bf">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="iris_types_8hpp.html#a25c2bd8a6f2445b1fd03387ea47c2b38">Result</a> Iris::__INTERNAL__Buffer::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrinks the underlying data block to fit the used space. </p>
<p>This is equivalent to calling resize(size()). This will not invalidate any pointers and is generally a safe way to reduce space consumption by buffers.</p>
<dl class="section return"><dt>Returns</dt><dd>IRIS_SUCCESS on successfully resizing the buffer object </dd></dl>

</div>
</div>
<a id="afaedad0adf27cf64d597f24ceacc9fc9" name="afaedad0adf27cf64d597f24ceacc9fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaedad0adf27cf64d597f24ceacc9fc9">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Iris::__INTERNAL__Buffer::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current size of the buffer. </p>
<p>This is distinct from the buffer capacity </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aef25184250bc213948be4fe83fb25cda" title="Returns the total capacity of the buffer (used and unused)">capacity()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>size_t number of bytes written to the buffer. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="iris_buffer_8hpp_source.html">IrisBuffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
